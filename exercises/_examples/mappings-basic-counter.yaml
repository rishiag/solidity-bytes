id: mappings-basic-counter
title: Mappings â€” per-user counters
difficulty: beginner
tags: [mappings, storage, basics]
objectives:
  - Use a mapping to store per-address counters
  - Increment and read counters
  - Emit events on updates
description: |
  Implement a contract that tracks a per-user counter using a `mapping(address => uint)`.
  
  Requirements:
  - `increment(uint by)` increases `counters[msg.sender]` by `by`.
  - `get(address who)` returns the current count for `who`.
  - Emit `Updated(address indexed who, uint newValue)` on increment.
hints:
  - Default value for unmapped keys is zero.
  - Use events to observe state changes in tests.
starter:
  files:
    - path: contracts/Counters.sol
      content: |
        // SPDX-License-Identifier: MIT
        pragma solidity ^0.8.20;

        contract Counters {
            event Updated(address indexed who, uint newValue);

            mapping(address => uint) private counters;

            function increment(uint by) external {
                // TODO: increment sender's counter and emit
            }

            function get(address who) external view returns (uint) {
                // TODO: return counter for who
            }
        }
    - path: hardhat.config.js
      content: |
        require("@nomicfoundation/hardhat-toolbox");
        module.exports = { solidity: "0.8.20" };
tests:
  files:
    - path: test/Counters.test.js
      content: |
        const { expect } = require("chai");
        const { ethers } = require("hardhat");

        describe("Counters", function () {
          it("increments and emits", async function () {
            const [a, b] = await ethers.getSigners();
            const Factory = await ethers.getContractFactory("Counters");
            const c = await Factory.deploy();
            await expect(c.connect(a).increment(2))
              .to.emit(c, "Updated")
              .withArgs(a.address, 2);
            await c.connect(b).increment(5);
            expect(await c.get(a.address)).to.equal(2);
            expect(await c.get(b.address)).to.equal(5);
          });
        });
solution:
  files:
    - path: contracts/Counters.sol
      content: |
        // SPDX-License-Identifier: MIT
        pragma solidity ^0.8.20;

        contract Counters {
            event Updated(address indexed who, uint newValue);

            mapping(address => uint) private counters;

            function increment(uint by) external {
                counters[msg.sender] += by;
                emit Updated(msg.sender, counters[msg.sender]);
            }

            function get(address who) external view returns (uint) {
                return counters[who];
            }
        }
visibility: after-pass

