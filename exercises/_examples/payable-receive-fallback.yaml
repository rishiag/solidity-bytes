id: payable-receive-fallback
title: ETH Basics â€” payable, receive, and fallback
difficulty: beginner
tags: [eth, payable, receive, fallback]
objectives:
  - Implement payable functions and receive/fallback handlers
  - Track total ETH received and per-sender deposits
  - Allow withdrawals by sender
description: |
  Implement a contract that can receive ETH in multiple ways and lets users withdraw their own deposits.
  
  Requirements:
  - `deposit()` is `payable` and credits `msg.sender`.
  - `receive()` should also credit `msg.sender` when ETH is sent with empty data.
  - `fallback()` should not credit but must be `payable` to avoid reverts; emit an event.
  - `withdraw(uint amount)` sends ETH back to `msg.sender` and reduces their balance; revert on insufficient funds.
  - `totalReceived()` returns the total ETH ever received.
hints:
  - Use `address(this).balance` for current balance, but track total separately if needed.
  - Prefer call pattern for sending ETH.
starter:
  files:
    - path: contracts/Vault.sol
      content: |
        // SPDX-License-Identifier: MIT
        pragma solidity ^0.8.20;

        contract Vault {
            event Deposited(address indexed from, uint amount, string via);
            event Fallback(address indexed from, uint amount);

            mapping(address => uint) private balances;
            uint private total;

            function deposit() external payable {
                // TODO: credit sender and emit Deposited with via="deposit"
            }

            receive() external payable {
                // TODO: credit sender and emit Deposited with via="receive"
            }

            fallback() external payable {
                // TODO: payable fallback; do not credit; emit Fallback
            }

            function withdraw(uint amount) external {
                // TODO: revert if insufficient; send using call and update balance
            }

            function totalReceived() external view returns (uint) {
                // TODO: return total received ever
            }

            function balanceOf(address who) external view returns (uint) {
                return balances[who];
            }
        }
    - path: hardhat.config.js
      content: |
        require("@nomicfoundation/hardhat-toolbox");
        module.exports = { solidity: "0.8.20" };
tests:
  files:
    - path: test/Vault.test.js
      content: |
        const { expect } = require("chai");
        const { ethers } = require("hardhat");

        describe("Vault", function () {
          it("deposit/receive/fallback behavior and withdraw", async function () {
            const [a, b] = await ethers.getSigners();
            const Factory = await ethers.getContractFactory("Vault");
            const v = await Factory.deploy();

            await expect(v.connect(a).deposit({ value: ethers.parseEther("1") }))
              .to.emit(v, "Deposited").withArgs(a.address, ethers.parseEther("1"), "deposit");

            await expect(a.sendTransaction({ to: v.target, value: ethers.parseEther("0.5") }))
              .to.emit(v, "Deposited").withArgs(a.address, ethers.parseEther("0.5"), "receive");

            // fallback: send with data
            await expect(a.sendTransaction({ to: v.target, value: ethers.parseEther("0.1"), data: "0x1234" }))
              .to.emit(v, "Fallback").withArgs(a.address, ethers.parseEther("0.1"));

            expect(await v.balanceOf(a.address)).to.equal(ethers.parseEther("1.5"));

            const before = await ethers.provider.getBalance(a.address);
            const tx = await v.connect(a).withdraw(ethers.parseEther("0.4"));
            await tx.wait();
            expect(await v.balanceOf(a.address)).to.equal(ethers.parseEther("1.1"));

            expect(await v.totalReceived()).to.equal(ethers.parseEther("1.6"));

            await expect(v.connect(b).withdraw(1)).to.be.reverted; // nothing to withdraw
          });
        });
solution:
  files:
    - path: contracts/Vault.sol
      content: |
        // SPDX-License-Identifier: MIT
        pragma solidity ^0.8.20;

        contract Vault {
            event Deposited(address indexed from, uint amount, string via);
            event Fallback(address indexed from, uint amount);

            mapping(address => uint) private balances;
            uint private total;

            function deposit() external payable {
                balances[msg.sender] += msg.value;
                total += msg.value;
                emit Deposited(msg.sender, msg.value, "deposit");
            }

            receive() external payable {
                balances[msg.sender] += msg.value;
                total += msg.value;
                emit Deposited(msg.sender, msg.value, "receive");
            }

            fallback() external payable {
                emit Fallback(msg.sender, msg.value);
            }

            function withdraw(uint amount) external {
                require(balances[msg.sender] >= amount, "INSUFFICIENT");
                balances[msg.sender] -= amount;
                (bool ok,) = payable(msg.sender).call{value: amount}("");
                require(ok, "SEND_FAIL");
            }

            function totalReceived() external view returns (uint) {
                return total;
            }

            function balanceOf(address who) external view returns (uint) {
                return balances[who];
            }
        }
visibility: after-pass

